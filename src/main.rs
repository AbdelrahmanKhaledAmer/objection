use std::env::args;
use std::fs::read_to_string;
use std::fs::remove_file;
use std::fs::write;
use std::process::Command;

mod lexer {
    pub mod lexer;
    pub mod tokens;
}

mod parser {
    pub mod ast;
    pub mod parser;
}

mod code_generator;

fn main() {
    // The command to run this compiler will have the following format:
    //     $ cargo run -- fname
    // I will also add some options to help us with debugging
    //     $ cargo run -- fname -t --ast --asm
    // The first argument is the name of the file to compile
    // The second argument is the option to print the tokens generated by the lexer
    // The third argument is the option to print the AST generated by the parser
    // The fourth argument is the option to print the assembly code generated by the code generator
    // All the arguments are optional except for the file name, and they can be in any order

    // Firstly, we will get the arguments passed to the program
    let args: Vec<String> = args().collect();
    let mut fname = "";
    let mut print_tokens = false;
    let mut print_ast = false;
    let mut print_asm = false;
    let mut store_asm = false;
    for arg in args.iter().skip(1) {
        if arg.starts_with("--") {
            match arg.as_str() {
                "--ast" => print_ast = true,
                "--asm" => print_asm = true,
                _ => panic!("Unknown option {}", arg),
            }
        } else if arg.starts_with('-') && arg.len() > 1 {
            for c in arg.chars().skip(1) {
                match c {
                    't' => print_tokens = true,
                    's' => store_asm = true,
                    _ => panic!("Unknown option {}", c),
                }
            }
        } else {
            if fname != "" {
                panic!("Multiple file names provided, {} and {}", fname, arg);
            }
            fname = arg;
        }
    }
    if fname == "" {
        panic!("No file name provided");
    }

    let fname_no_ext = fname.split('.').collect::<Vec<&str>>()[0];

    // Now we will read the file and pass it to the lexer
    let src = read_to_string(&fname).expect(format!("Could not read file {}", fname).as_str());
    let tokens = lexer::lexer::get_tokens(src);
    // Print the tokens if the option is enabled
    if print_tokens {
        println!("{:?}", tokens);
    }

    // We will now pass the tokens to the parser
    let ast = parser::parser::parse_prog(tokens);
    // Print the AST if the option is enabled
    if print_ast {
        println!("{:?}", ast);
    }

    // Now we will use the AST to generate assembly code.
    // However, we need to know the target platform to generate the correct code.
    // We will use the code_generator_factory function to create the correct code generator.
    let generator = code_generator::code_generator_factory();
    let asm = generator.generate(&ast);
    // Print the assembly code if the option is enabled
    if print_asm {
        println!("{}", asm);
    }

    // Last step, we will create the executable
    if store_asm {
        let asm_fname = format!("{}.s", &fname_no_ext);
        write(&asm_fname, &asm).expect(format!("Could not write file {}", &asm_fname).as_str());
    }
    // First step is to assemble the code
    let asm_fname = format!("{}_tmp.s", &fname_no_ext);
    write(&asm_fname, &asm).expect(format!("Could not write file {}", &asm_fname).as_str());
    let obj_fname = format!("{}_tmp.o", &fname_no_ext);
    Command::new("as")
        .arg("-o")
        .arg(&obj_fname)
        .arg(&asm_fname)
        .output()
        .expect("Failed to assemble the code");
    // Next, we will link the object file
    Command::new("ld")
        .arg("-o")
        .arg(&fname_no_ext)
        .arg(&obj_fname)
        .output()
        .expect("Failed to link the object file");
    // Finally, we will remove the temporary files
    remove_file(&asm_fname).expect("Failed to remove the temporary assembly file");
    remove_file(&obj_fname).expect("Failed to remove the temporary object file");
}
